let push: (T: Any -> T -> [T..] -> [T..]) <==
    T: Any -(T -> [T..] -> [T..])-> el: T -([T..] -> [T..])-> list: [T..] -[T..]->
        (el list) |> @hook("std.list.push"  ((T  [T..]) -> [T..]))
let is_empty: (T: Any -> [T..] -> Bool) <==
    @hook("std.list.is_empty" (T: Any -> [T..] -> Bool))
let head: (T: Any -> [T..] -> T) <==
    @hook("std.list.head" (T: Any -> [T..] -> T))
let tail: (T: Any -> [T..] -> [T..]) <==
    @hook("std.list.tail" (T: Any -> [T..] -> [T..]))

let concat: (T: Any -> [T..] -> [T..] -> [T..]) <==
    T: Any -([T..] -> [T..] -> [T..])->
    first: [T..] -([T..] -> [T..])->
    second: [T..] -[T..]->
        if first |> (is_empty <| type T) then
            second
        else if second |> (is_empty <| type T) then
            first
        else
            (push <| type T)
                <| (first |> (head <| type T))
                <| (first |> (tail <| type T) |> (concat <| type T) <| second)

let some_numbers: [Int..] <== [1 2 3]
let empty: [Int..] <== []

some_numbers
    |> (concat <| type Int) <| empty
    |> (concat <| type Int) <| []
    |> (concat <| type Int) <| [4]
