let concat: (T: Any -> [T..] -> [T..] -> [T..]) <==
    T: Any -([T..] -> [T..] -> [T..])->
    first: [T..] -([T..] -> [T..])->
    second: [T..] -[T..]->
        if first |> (is_empty <| type T) then
            second
        else if second |> (is_empty <| type T) then
            first
        else
            (push <| type T)
                <| (first |> (head <| type T))
                <| (first |> (tail <| type T) |> (concat <| type T) <| second)

let some_numbers: [Int..] <== [1 2 3]
let empty: [Int..] <== []

some_numbers
    |> (concat <| type Int) <| empty
    |> (concat <| type Int) <| []
    |> (concat <| type Int) <| [4]
