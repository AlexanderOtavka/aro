use std::str::FromStr;
use ast::{Ast, Expression, BinOp, Value, Type, Pattern};

grammar;

pub Type: Ast<Type> = {
    <l:@L> <p:ValueType> "->" <e:Type> <r:@R> => Ast::<Type>::new(l, r, Type::Func(p, e)),
    ValueType,
};

ValueType = {
    <l:@L> "Int" <r:@R> => Ast::<Type>::new(l, r, Type::Int),
    <l:@L> "Float" <r:@R> => Ast::<Type>::new(l, r, Type::Float),
    <l:@L> "Bool" <r:@R> => Ast::<Type>::new(l, r, Type::Bool),

    <l:@L> "(" ")" <r:@R> => Ast::<Type>::new(l, r, Type::Tuple(vec![])),
    <l:@L> "(" <h:Type> <t: Type+ > ")" <r:@R> => Ast::<Type>::new(l, r, Type::Tuple({
        let mut vec = t;
        vec.insert(0, h);
        vec
    })),

    "(" <Type> ")",
};

pub Expr: Ast<Expression> = {
    <l:@L> "if" <e1:Expr> "then" <e2:Expr> "else" <e3:Expr> <r:@R> =>
        Ast::<Expression>::new(l, r, Expression::If(e1, e2, e3)),

    <l:@L> "let" <p:Pattern> "<==" <v:Expr> <e:Expr> <r:@R> =>
        Ast::<Expression>::new(l, r, Expression::Let(p, v, e)),

    <l:@L> <p:IdentPattern> "-" <et:ValueType> "->" <e:Expr> <r:@R> =>
        Ast::<Expression>::new(l, r, Expression::Value(Value::Func(p, et, e))),
    <l:@L> "fn" <p:Pattern> "-" <et:ValueType> "->" <e:Expr> <r:@R> =>
        Ast::<Expression>::new(l, r, Expression::Value(Value::Func(p, et, e))),

    Call,
};

Call = {
    <l:@L> <f:Call> "<|" <a:Comp> <r:@R> => Ast::<Expression>::new(l, r, Expression::BinOp(BinOp::Call, f, a)),
    <l:@L> <a:Call> "|>" <f:Comp> <r:@R> => Ast::<Expression>::new(l, r, Expression::BinOp(BinOp::Call, f, a)),
    Comp,
};

Comp = {
    <l:@L> <a:Comp> "<=" <b:Arith> <r:@R> => Ast::<Expression>::new(l, r, Expression::BinOp(BinOp::LEq, a, b)),
    Arith,
};

Arith = {
    <l:@L> <a:Arith> "+" <b:Factor> <r:@R> => Ast::<Expression>::new(l, r, Expression::BinOp(BinOp::Add, a, b)),
    <l:@L> <a:Arith> "-" <b:Factor> <r:@R> => Ast::<Expression>::new(l, r, Expression::BinOp(BinOp::Sub, a, b)),
    Factor,
};

Factor = {
    <l:@L> <a:Factor> "*" <b:Value> <r:@R> => Ast::<Expression>::new(l, r, Expression::BinOp(BinOp::Mul, a, b)),
    <l:@L> <a:Factor> "/" <b:Value> <r:@R> => Ast::<Expression>::new(l, r, Expression::BinOp(BinOp::Div, a, b)),
    Value,
};

Value = {
    <l:@L> <v:Int> <r:@R> => Ast::<Expression>::new(l, r, Expression::Value(Value::Int(v))),
    <l:@L> <v:Float> <r:@R> => Ast::<Expression>::new(l, r, Expression::Value(Value::Float(v))),
    <l:@L> <v:Bool> <r:@R> => Ast::<Expression>::new(l, r, Expression::Value(Value::Bool(v))),
    <l:@L> <v:Ident> <r:@R> => Ast::<Expression>::new(l, r, Expression::Ident(v)),

    <l:@L> "(" ")" <r:@R> => Ast::<Expression>::new(l, r, Expression::Value(Value::Tuple(vec![]))),
    <l:@L> "(" <h:Expr> <t: Expr+ > ")" <r:@R> => Ast::<Expression>::new(l, r, Expression::Value(Value::Tuple({
        let mut vec = t;
        vec.insert(0, h);
        vec
    }))),

    "(" <Expr> ")",
};

Pattern: Ast<Pattern> = {
    <l:@L> "(" ")" <r:@R> => Ast::<Pattern>::new(l, r, Pattern::Tuple(vec![])),
    <l:@L> "(" <h:Pattern> <t: Pattern+ > ")" <r:@R> =>  Ast::<Pattern>::new(l, r, Pattern::Tuple({
        let mut vec = t;
        vec.insert(0, h);
        vec
    })),

    IdentPattern,

    "(" <Pattern> ")"
};

IdentPattern: Ast<Pattern> = {
    <l:@L> <n:Ident> ":" <t:ValueType> <r:@R> => Ast::<Pattern>::new(l, r, Pattern::Ident(n, t)),
};

Float: f64 = {
    r"-?[0-9]+\.[0-9]+" => f64::from_str(<>).unwrap(),
};

Ident: String = {
    r"[a-z](_?[a-z])*" => String::from(<>),
};

Int: i32 = {
    r"-?[0-9]+" => i32::from_str(<>).unwrap(),
};

Bool: bool = {
    r"#true" "(" ")" => true,
    r"#false" "(" ")" => false,
};
