use std::str::FromStr;
use ast::{Ast, Expression, BinOp, Value, TypeAst, Type};

grammar;

pub Type: TypeAst = {
    <p:ValueType> <l:@L> "->" <r:@R> <e:Type> =>
        TypeAst::new(l, r, Type::Func(p, e)),
    ValueType,
};

ValueType = {
    <l:@L> "Int" <r:@R> => TypeAst::new(l, r, Type::Int),
    <l:@L> "Float" <r:@R> => TypeAst::new(l, r, Type::Float),
    <l:@L> "Bool" <r:@R> => TypeAst::new(l, r, Type::Bool),
    "(" <Type> ")",
};

pub Expr: Ast = {
    <l:@L> "if" <e1:Expr> "then" <e2:Expr> "else" <e3:Expr> <r:@R> =>
        Ast::new(l, r, Expression::If(e1, e2, e3)),
    <l:@L> "let" <n:Ident> ":" <t:Type> "<==" <v:Expr> <e:Expr> <r:@R> =>
        Ast::new(l, r, Expression::Let(n, t, v, e)),
    <l:@L> <p:Ident> ":" <pt:ValueType> "-" <et:ValueType> "->" <e:Expr> <r:@R> =>
        Ast::new(l, r, Expression::Value(Value::Func(p, pt, et, e))),
    Call,
};

Call = {
    <f:Call> <l:@L> "<|" <r:@R> <a:Comp> =>
        Ast::new(l, r, Expression::BinOp(BinOp::Call, f, a)),
    <a:Call> <l:@L> "|>" <r:@R> <f:Comp> =>
        Ast::new(l, r, Expression::BinOp(BinOp::Call, f, a)),
    Comp,
};

Comp = {
    <a:Comp> <l:@L> "<=" <r:@R> <b:Arith> =>
        Ast::new(l, r, Expression::BinOp(BinOp::LEq, a, b)),
    Arith,
};

Arith = {
    <a:Arith> <l:@L> "+" <r:@R> <b:Factor> =>
        Ast::new(l, r, Expression::BinOp(BinOp::Add, a, b)),
    <a:Arith> <l:@L> "-" <r:@R> <b:Factor> =>
        Ast::new(l, r, Expression::BinOp(BinOp::Sub, a, b)),
    Factor,
};

Factor = {
    <a:Factor> <l:@L> "*" <r:@R> <b:Value> => Ast::new(l, r, Expression::BinOp(BinOp::Mul, a, b)),
    <a:Factor> <l:@L> "/" <r:@R> <b:Value> => Ast::new(l, r, Expression::BinOp(BinOp::Div, a, b)),
    Value,
};

Value = {
    <l:@L> <v:Int> <r:@R> => Ast::new(l, r, Expression::Value(Value::Int(v))),
    <l:@L> <v:Float> <r:@R> => Ast::new(l, r, Expression::Value(Value::Float(v))),
    <l:@L> <v:Bool> <r:@R> => Ast::new(l, r, Expression::Value(Value::Bool(v))),
    <l:@L> <v:Ident> <r:@R> => Ast::new(l, r, Expression::Ident(v)),
    "(" <Expr> ")",
};

Float: f64 = {
    r"-?[0-9]+\.[0-9]+" => f64::from_str(<>).unwrap(),
};

Ident: String = {
    r"[a-z](_?[a-z])*" => String::from(<>),
};

Int: i32 = {
    r"-?[0-9]+" => i32::from_str(<>).unwrap(),
};

Bool: bool = {
    r"#true" "(" ")" => true,
    r"#false" "(" ")" => false,
};
