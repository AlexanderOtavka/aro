use std::str::FromStr;
use ast::{Ast, Expression, BinOp, Value};

grammar;

pub Expr: Ast = {
    <l:@L> "if" <e1:Expr> "then" <e2:Expr> "else" <e3:Expr> <r:@R> =>
        Ast::new(l, r, Expression::If(e1, e2, e3)),
    <l:@L> "let" <n:Ident> "<==" <v:Expr> <e:Expr> <r:@R> =>
        Ast::new(l, r, Expression::Let(n, v, e)),
    <p:Ident> <l:@L> "->" <r:@R> <e:Expr> =>
        Ast::new(l, r, Expression::Value(Value::Func(p, e))),
    Call,
};

Call = {
    <f:Call> <l:@L> "<|" <r:@R> <a:Comp> =>
        Ast::new(l, r, Expression::BinOp(BinOp::Call, f, a)),
    <a:Call> <l:@L> "|>" <r:@R> <f:Comp> =>
        Ast::new(l, r, Expression::BinOp(BinOp::Call, f, a)),
    Comp,
};

Comp = {
    <a:Comp> <l:@L> "<=" <r:@R> <b:Arith> =>
        Ast::new(l, r, Expression::BinOp(BinOp::LEq, a, b)),
    Arith,
};

Arith = {
    <a:Arith> <l:@L> "+" <r:@R> <b:Factor> =>
        Ast::new(l, r, Expression::BinOp(BinOp::Add, a, b)),
    <a:Arith> <l:@L> "-" <r:@R> <b:Factor> =>
        Ast::new(l, r, Expression::BinOp(BinOp::Sub, a, b)),
    Factor,
};

Factor = {
    <a:Factor> <l:@L> "*" <r:@R> <b:Value> => Ast::new(l, r, Expression::BinOp(BinOp::Mul, a, b)),
    <a:Factor> <l:@L> "/" <r:@R> <b:Value> => Ast::new(l, r, Expression::BinOp(BinOp::Div, a, b)),
    Value,
};

Value = {
    <l:@L> <v:Int> <r:@R> => Ast::new(l, r, Expression::Value(Value::Int(v))),
    <l:@L> <v:Float> <r:@R> => Ast::new(l, r, Expression::Value(Value::Float(v))),
    <l:@L> <v:Bool> <r:@R> => Ast::new(l, r, Expression::Value(Value::Bool(v))),
    <l:@L> <v:Ident> <r:@R> => Ast::new(l, r, Expression::Ident(v)),
    "(" <Expr> ")",
};

Float: f64 = {
    r"-?[0-9]+\.[0-9]+" => f64::from_str(<>).unwrap(),
};

Ident: String = {
    r"[a-z][a-z_]*" => String::from(<>),
};

Int: i32 = {
    r"-?[0-9]+" => i32::from_str(<>).unwrap(),
};

Bool: bool = {
    r"#true" "(" ")" => true,
    r"#false" "(" ")" => false,
};
